        -:    0:Source:randomtestcard1.c
        -:    0:Graph:randomtestcard1.gcno
        -:    0:Data:randomtestcard1.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/*
        -:    2:**	Emily Hamilton (ONID: hamiltem, ID: 933281100)
        -:    3:**	Assignment 4 - CS362 Spring 2018
        -:    4:**	Due 5/13/18
        -:    5:*/
        -:    6:
        -:    7:/*
        -:    8:**		~     RANDOM CARD TEST 1     ~
        -:    9:**	File:				randomtestcard1.c
        -:   10:**	Card Tested:		Smithy
        -:   11:**	Code Origin:		dominion_helpers.h, dominion.c
        -:   12:*/
        -:   13:
        -:   14:#include "dominion.h"
        -:   15:#include "dominion_helpers.h"
        -:   16:#include "rngs.h"
        -:   17:#include <stdio.h>
        -:   18:#include <stdlib.h>
        -:   19:#include <string.h>
        -:   20:#include <time.h>
        -:   21:
        -:   22:#define NUM_TESTS 2000
        -:   23:
        -:   24:/* Global Variables */
        -:   25:int numPass;
        -:   26:int numFail;
        -:   27:int totalPasses;
        -:   28:int totalFailures;
        -:   29:
        -:   30:/* Function prototypes */
        -:   31:int getRandNum(int min, int max);
        -:   32:int getRandNumPosNeg();
        -:   33:int assertEqual(int a, int b);
        -:   34:void testResults(struct gameState *state, struct gameState *oracle, int activePlayer, int handPos);
        -:   35:
function main called 1 returned 100% blocks executed 100%
        1:   36:int main()
        -:   37:{
        -:   38:	int numPlayers,
        -:   39:		activePlayer,
        -:   40:		handPos,
        -:   41:		choice1,
        -:   42:		choice2,
        -:   43:		choice3,
        -:   44:		bonus,
        -:   45:		i, j,
        -:   46:		result,
        -:   47:		currentTest;
        -:   48:	
        -:   49:	double percentPass, 
        -:   50:		percentFailure;
        -:   51:	
        -:   52:	time_t seed;
        -:   53:
        -:   54:	//Declare test gameState structs
        -:   55:	struct gameState state, oracle;
        -:   56:	
        1:   57:	printf("-------------------- RANDOM CARD TEST 1: SMITHY ----------------------\n\n");
call    0 returned 100%
        -:   58:
        -:   59:	// Use time to set seed for random number generation
        1:   60:	seed = time(NULL);
call    0 returned 100%
        1:   61:	srand(time(NULL));
call    0 returned 100%
call    1 returned 100%
        1:   62:	printf("Seed: %lld\n", (long long)seed);
call    0 returned 100%
        -:   63:
        1:   64:	totalFailures = 0;
        1:   65:	totalPasses = 0;
        -:   66:
     2001:   67:	for (currentTest = 0; currentTest < NUM_TESTS; currentTest++) {
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
        -:   68:
     2000:   69:		printf("TEST %d --------------------------------------------------------------\n", currentTest);
call    0 returned 100%
        -:   70:
        -:   71:		// Initialize test counts
     2000:   72:		numPass = 0;
     2000:   73:		numFail = 0;
        -:   74:
        -:   75:		//Randomize contents of GameState state 
 52602000:   76:		for (i = 0; i < sizeof(struct gameState); i++) {
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
 52600000:   77:			((char*)&state)[i] = getRandNum(0, 256);
call    0 returned 100%
        -:   78:		}
        -:   79:
        -:   80:		/*	Randomly generate values that could influence how Smithy functions	*/
        -:   81:
        -:   82:		// Number of players
     2000:   83:		numPlayers = getRandNum(0, MAX_PLAYERS);
call    0 returned 100%
     2000:   84:		state.numPlayers = numPlayers;
     2000:   85:		printf("Number of Players: %d\n", numPlayers);
call    0 returned 100%
        -:   86:
        -:   87:		// Select active player
     2000:   88:		activePlayer = getRandNum(0, MAX_PLAYERS - 1);
call    0 returned 100%
     2000:   89:		state.whoseTurn = activePlayer;
     2000:   90:		printf("Active Player: %d\n", activePlayer);
call    0 returned 100%
        -:   91:
        -:   92:		// Hand Size -- I originally set the upper bound to MAX_HAND, but this created a
        -:   93:		// seg fault when the hand is incremented (by 2 or 3, depending on whether the
        -:   94:		// bug I introduced in HW2 reared its ugly head or not). I changed the upper limit
        -:   95:		// to MAX_HAND - 3 to stop the seg fault from occurring.
    10000:   96:		for (i = 0; i < MAX_PLAYERS; i++) {
branch  0 taken 80%
branch  1 taken 20% (fallthrough)
     8000:   97:			state.handCount[i] = getRandNum(0, MAX_HAND - 3);
call    0 returned 100%
     8000:   98:			printf("Hand Size Player %d: %d\n", i, state.handCount[i]);
call    0 returned 100%
        -:   99:		}
        -:  100:
        -:  101:		// Hand Position of Smithy card in player's hand -- can only be 0 or 1 to
        -:  102:		// avoid segmentation fault in all cases due to bug I introduced in _smithy()
        -:  103:		// in HW2.
     2000:  104:		handPos = getRandNum(0, 1);
call    0 returned 100%
     2000:  105:		printf("Hand Position of Smithy: %d\n", handPos);
call    0 returned 100%
        -:  106:
        -:  107:		// Players' Hand Contents
    10000:  108:		for (i = 0; i < MAX_PLAYERS; i++) {
branch  0 taken 80%
branch  1 taken 20% (fallthrough)
  4008000:  109:			for (j = 0; j < MAX_HAND; j++) {
branch  0 taken 99%
branch  1 taken 1% (fallthrough)
  4000000:  110:				state.hand[i][j] = getRandNum(curse, treasure_map);
call    0 returned 100%
        -:  111:			}
        -:  112:		}
     2000:  113:		state.hand[activePlayer][handPos] = smithy;
        -:  114:
        -:  115:		// Deck Size -- I originally set the lower bound to 0, but this created a seg fault
        -:  116:		// if the deck size was less than the number of cards to draw (3).
    10000:  117:		for (i = 0; i < MAX_PLAYERS; i++) {
branch  0 taken 80%
branch  1 taken 20% (fallthrough)
     8000:  118:			state.deckCount[i] = getRandNum(3, MAX_DECK);
call    0 returned 100%
     8000:  119:			printf("Deck Size Player %d: %d\n", i, state.deckCount[i]);
call    0 returned 100%
        -:  120:		}
        -:  121:
        -:  122:		// playedCardCount
     2000:  123:		state.playedCardCount = getRandNum(0, MAX_DECK);
call    0 returned 100%
     2000:  124:		printf("Played Card Count = %d\n", state.playedCardCount);
call    0 returned 100%
        -:  125:
        -:  126:		// Randomize values of choices/bonus passed to cardEffect-- none of these should have
        -:  127:		// an effect on Smithy, since smithy does not require choice parameters or make a
        -:  128:		// call to updateCoins() with a bonus.
     2000:  129:		state.coins = getRandNumPosNeg();	//No range defined
call    0 returned 100%
     2000:  130:		choice1 = getRandNumPosNeg();
call    0 returned 100%
     2000:  131:		choice2 = getRandNumPosNeg();
call    0 returned 100%
     2000:  132:		choice3 = getRandNumPosNeg();
call    0 returned 100%
     2000:  133:		bonus = getRandNumPosNeg();
call    0 returned 100%
     2000:  134:		printf("Coins: %d\n", state.coins);
call    0 returned 100%
     2000:  135:		printf("Choice 1: %d\n", choice1);
call    0 returned 100%
     2000:  136:		printf("Choice 2: %d\n", choice2);
call    0 returned 100%
     2000:  137:		printf("Choice 3: %d\n", choice3);
call    0 returned 100%
     2000:  138:		printf("Bonus: %d\n", bonus);
call    0 returned 100%
        -:  139:
        -:  140:		/*	Copy state to oracle	*/
     2000:  141:		memcpy(&oracle, &state, sizeof(struct gameState));
        -:  142:
        -:  143:		/* CALL CARD EFFECT!!! */
     2000:  144:		result = cardEffect(smithy, choice1, choice2, choice3, &state, handPos, &bonus);
call    0 returned 100%
     2000:  145:		printf("Result: %d\n", result);
call    0 returned 100%
        -:  146:
        -:  147:		/* CHECK RESULTS */
        -:  148:
        -:  149:		//Check return value
     2000:  150:		assertEqual(result, 0);
call    0 returned 100%
        -:  151:
        -:  152:		//Check everything else
     2000:  153:		testResults(&state, &oracle, activePlayer, handPos);
call    0 returned 100%
        -:  154:
     2000:  155:		printf("\n----------------------------------------------------------------------\n\n");
call    0 returned 100%
     2000:  156:		printf("TEST RESULTS:\n");
call    0 returned 100%
     2000:  157:		printf("Number of Passes: %d\n", numPass);
call    0 returned 100%
     2000:  158:		printf("Number of Failures: %d\n", numFail);
call    0 returned 100%
     2000:  159:		printf("\n----------------------------------------------------------------------\n");
call    0 returned 100%
        -:  160:
     2000:  161:		if (numFail > 0) {
branch  0 taken 1% (fallthrough)
branch  1 taken 99%
        9:  162:			totalFailures++;
        -:  163:		}
        -:  164:		else {
     1991:  165:			totalPasses++;
        -:  166:		}
        -:  167:	}
        -:  168:
        1:  169:	percentPass = ((double)totalPasses / (double)NUM_TESTS) * 100;
        1:  170:	percentFailure = ((double)totalFailures / (double)NUM_TESTS) * 100;
        -:  171:
        -:  172:
        1:  173:	printf("ALL TESTS:\n");
call    0 returned 100%
        1:  174:	printf("Tests with No Identified Failures:\t%d / %d\n", totalPasses, NUM_TESTS);
call    0 returned 100%
        1:  175:	printf("\t\tPercentage Passed:\t%.2f%%\n", percentPass);
call    0 returned 100%
        1:  176:	printf("Tests with Identified Failures:\t\t%d / %d\n", totalFailures, NUM_TESTS);
call    0 returned 100%
        1:  177:	printf("\t\tPercentage Failed:\t%.2f%%\n", percentFailure);
call    0 returned 100%
        1:  178:	assertEqual(totalPasses + totalFailures, 2000);
call    0 returned 100%
        1:  179:	printf("----------------------------------------------------------------------\n");
call    0 returned 100%
        1:  180:	return 0;
        -:  181:}
        -:  182:
        -:  183:/* 
        -:  184:** getRandNum -- returns a pseudorandom integer with a minimum possible value of
        -:  185:** min and a maximum possible value of max.
        -:  186:*/
function getRandNum called 56634000 returned 100% blocks executed 100%
 56634000:  187:int getRandNum(int min, int max) {
 56634000:  188:	int num = (rand() % (max - min + 1)) + min;
call    0 returned 100%
 56634000:  189:	return num;
        -:  190:}
        -:  191:
        -:  192:/*
        -:  193:** getRandNumPosNeg -- returns a pseudorandom signed integer between -RAND_MAX/2 and 
        -:  194:** RAND_MAX/2.
        -:  195:*/
function getRandNumPosNeg called 10000 returned 100% blocks executed 100%
    10000:  196:int getRandNumPosNeg() {
        -:  197:	int m, n;
    10000:  198:	m = getRandNum(0, RAND_MAX);
call    0 returned 100%
    10000:  199:	n = RAND_MAX / 2;
    10000:  200:	return m - n;
        -:  201:}
        -:  202:
        -:  203:/*
        -:  204:** assertEqual -- asserts that its two integer arguments are equal. If they are, it increments the
        -:  205:** global numPass variable and returns 1 (true); if they are not, it increments the global numFail
        -:  206:** variable and returns 0 (false).
        -:  207:*/
function assertEqual called 26001 returned 100% blocks executed 100%
    26001:  208:int assertEqual(int a, int b) {
    26001:  209:	if (a == b) {
branch  0 taken 99% (fallthrough)
branch  1 taken 1%
    25989:  210:		numPass++;
    25989:  211:		return 1;
        -:  212:	}
        -:  213:	else {
       12:  214:		numFail++;
       12:  215:		return 0;
        -:  216:	}
        -:  217:}
        -:  218:
        -:  219:
        -:  220:/*
        -:  221:** testResults -- evaluates the gameState struct used for testing (*state) against a test oracle based
        -:  222:** on the state's values before cardEffect was executed (*oracle). The integer arguments activePlayer
        -:  223:** and handPos represent the player who played the card and the position the card was played from in
        -:  224:** that player's hand, respectively. For each test case, a call is made to assertEqual, which increments
        -:  225:** the numPass or numFail global variables according to whether or not the resulting game state matches
        -:  226:** the expected outcome of the card's effect.
        -:  227:*/
function testResults called 2000 returned 100% blocks executed 75%
     2000:  228:void testResults(struct gameState *state, struct gameState *oracle, int activePlayer, int handPos) {
        -:  229:	int result, expected, i;
        -:  230:
        -:  231:	// 1. Active player's hand count has been increased by 3 - 1 = 2.
     2000:  232:	result = state->handCount[activePlayer];
     2000:  233:	expected = oracle->handCount[activePlayer] + 2;
     2000:  234:	if (assertEqual(result, expected) == 0) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  235:		printf("Test Failed: Player %d\'s hand count not increased from %d to %d.\n",
call    0 never executed
        -:  236:			activePlayer, oracle->handCount[activePlayer], expected);
    #####:  237:		printf("\tPlayer %d\'s hand count: %d\n", activePlayer, result);
call    0 never executed
        -:  238:	}
        -:  239:
        -:  240:	// 2. All other players' hand counts are the same.
    10000:  241:	for (i = 0; i < MAX_PLAYERS; i++) {
branch  0 taken 80%
branch  1 taken 20% (fallthrough)
     8000:  242:		if (i != activePlayer) {
branch  0 taken 75% (fallthrough)
branch  1 taken 25%
     6000:  243:			result = state->handCount[i];
     6000:  244:			expected = oracle->handCount[i];
     6000:  245:			if (assertEqual(result, expected) == 0) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  246:				printf("Test Failed: Non-active player %d\'s hand count changed from %d to %d.\n",
call    0 never executed
        -:  247:					i, expected, result);
        -:  248:			}
        -:  249:		}
        -:  250:	}
        -:  251:
        -:  252:	// 3. Active player's deck size is decreased by 3.
     2000:  253:	result = state->deckCount[activePlayer];
     2000:  254:	expected = oracle->deckCount[activePlayer] - 3;
     2000:  255:	if (assertEqual(result, expected) == 0) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  256:		printf("Test Failed: Player %d\'s deck count not decreased from %d to %d.\n",
call    0 never executed
        -:  257:			activePlayer, oracle->deckCount[activePlayer], expected);
    #####:  258:		printf("\tPlayer %d\'s deck count: %d\n", activePlayer, result);
call    0 never executed
        -:  259:	}
        -:  260:
        -:  261:	// 4. All other players' deck counts are the same.
    10000:  262:	for (i = 0; i < MAX_PLAYERS; i++) {
branch  0 taken 80%
branch  1 taken 20% (fallthrough)
     8000:  263:		if (i != activePlayer) {
branch  0 taken 75% (fallthrough)
branch  1 taken 25%
     6000:  264:			result = state->deckCount[i];
     6000:  265:			expected = oracle->deckCount[i];
     6000:  266:			if (assertEqual(result, expected) == 0) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  267:				printf("Test Failed: Non-active player %d\'s deck count changed from %d to %d.\n",
call    0 never executed
        -:  268:					i, expected, result);
        -:  269:			}
        -:  270:		}
        -:  271:	}
        -:  272:
        -:  273:	// 5. playedCardCount has been increased by 1.
     2000:  274:	result = state->playedCardCount;
     2000:  275:	expected = oracle->playedCardCount + 1;
     2000:  276:	if (assertEqual(result, expected) == 0) {
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 99%
        3:  277:		printf("Test Failed: playedCard count not incremented from %d to %d.\n", 
call    0 returned 100%
        -:  278:			oracle->playedCardCount, expected);
        -:  279:	}
        -:  280:
        -:  281:	// 6. Last card in playedCards array is Smithy
     2000:  282:	result = state->playedCards[state->playedCardCount - 1];
     2000:  283:	expected = smithy;
     2000:  284:	if (assertEqual(result, expected) == 0) {
call    0 returned 100%
branch  1 taken 1% (fallthrough)
branch  2 taken 99%
        9:  285:		printf("Test Failed: Last card in playedCards array (%d) is not smithy (= 13).\n", result);
call    0 returned 100%
        -:  286:	}
        -:  287:
        -:  288:	// 7. Player's hand at handPos now contains last-drawn card
     2000:  289:	result = state->hand[activePlayer][handPos];
     2000:  290:	expected = oracle->deck[activePlayer][oracle->deckCount[activePlayer] - 3];
     2000:  291:	if (assertEqual(result, expected) == 0) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  292:		printf("Test Failed: Player %d\'s hand at hand position %d has not been replaced\nwith the last-drawn card %d.\n",
call    0 never executed
        -:  293:			activePlayer, handPos, expected);
    #####:  294:		printf("\tPlayer %d\'s hand at hand position %d: %d\n", activePlayer, handPos, result);
call    0 never executed
        -:  295:	}
        -:  296:
        -:  297:	// 8. Coins should not have been changed
     2000:  298:	result = state->coins;
     2000:  299:	expected = oracle->coins;
     2000:  300:	if (assertEqual(result, expected) == 0) {
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:  301:		printf("Test Failed: Game coins changed from %d to %d.\n", expected, result);
call    0 never executed
        -:  302:	}
        -:  303:
     2000:  304:}
